// -*- C++ -*-
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//                                   Jiao Lin
//                      California Institute of Technology
//                      (C) 2007-2008  All Rights Reserved
//
// {LicenseText}
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//


#ifndef DANSE_REDUCTION_IPIXE2IPHIE_ICC
#error Template definitions meaningless outside of IpixE2IphiE.h
#endif

#include <cassert>
#include <cmath>
//#include <iostream>
#include <sstream>
#include "exception.h"
#include "histogram/EvenlySpacedGridData_1D.h"
#include "Histogrammer.h"


namespace DANSE { namespace Reduction{

    /// implementation details
    namespace IpixE2IphiE_impl {
      
      const extern char *jrnltag;
      
      template <typename IntensityIterator, typename FLT>
      struct Y{
	IntensityIterator intensity_it, intensityE2_it;
	FLT *solidangle, *solidangleE2;
	size_t nEbins;

	Y(IntensityIterator i_intensity_it, IntensityIterator i_intensityE2_it,
	  FLT &i_solidangle, FLT &i_solidangleE2,
	  size_t i_nEbins)
	  : intensity_it(i_intensity_it), intensityE2_it(i_intensityE2_it),
	    solidangle(&i_solidangle), solidangleE2(&i_solidangleE2),
	    nEbins(i_nEbins)
	{
	}
	
	Y()
	  : solidangle(0), solidangleE2(0)
	{
	}
	
	typedef Y<IntensityIterator, FLT> y_t;
	y_t & operator+= (const y_t &rhs) {
	  assert (nEbins > 0);
	  assert (nEbins == rhs.nEbins);
	  *solidangle += *(rhs.solidangle);
	  *solidangleE2 += *(rhs.solidangleE2);
	  for (size_t i=0; i<nEbins; i++) {
	    *(intensity_it+i) += *(rhs.intensity_it+i);
	    *(intensityE2_it+i) += *(rhs.intensityE2_it+i);
	  }
	  return *this;
	}
      };
      
      
      // container
      template <typename IntensityIterator, typename SolidangleIterator, typename FLT>
      class YContainer{
      public:
	
	// types
	typedef YContainer<IntensityIterator, SolidangleIterator, FLT> mytype;
	typedef Y<IntensityIterator, FLT> mydatatype;
	
	// iterator to iterate over phi axis of I(phi, E) and solidangle(phi)
	struct YIterator{
	
	  // types
	  typedef YContainer<IntensityIterator, SolidangleIterator, FLT> mycontainertype;
	
	  // meta-methods
	  YIterator(mycontainertype &container)
	    : m_container(&container),
	      m_index(0)
	  {
	  }
	  
	  YIterator(const YIterator &rhs) {
	    m_container = rhs.m_container;
	    m_index = rhs.m_index;
	  }

	  YIterator()
	    : m_container(0),
	      m_index(0)
	  {
	  }
	
	  YIterator &operator++()
	  {
	    ++m_index;
	    return *this;
	  }
	
	  YIterator &operator+=(size_t n)
	  {
	    m_index += n;
	    return *this;
	  }

	  YIterator operator+(size_t n)
	  {
	    YIterator ret(*this);
	    ret += n;
	    return ret;
	  }
	
	  bool operator < ( const YIterator & rhs ) 
	  {
	    return m_index < rhs.m_index;
	  }
		
	  mydatatype & operator*() {
	    if (m_container == 0) throw Exception("Invalid iterator: not initd");

	    return m_container->getElement(m_index);
	  }

	  mycontainertype *m_container;
	  size_t m_index;
	};
	typedef YIterator iterator_t;
	
	// meta-methods
	YContainer(IntensityIterator I_begin, IntensityIterator IE2_begin,
		   SolidangleIterator sa_begin, SolidangleIterator saE2_begin,
		   size_t nphibins, size_t nEbins)
	  : m_I_begin(I_begin), m_IE2_begin(IE2_begin),
	    m_sa_begin(sa_begin), m_saE2_begine(saE2_begin),
	    m_nphibins(nphibins), m_nEbins(nEbins)
	{
	}
	
	mydatatype & getElement(size_t index)
	{
	  if (index<0 || index>m_nphibins) {
	    std::ostringstream oss;
	    oss << "out of bound: " 
		<< "index=" << index << ", "
		<< "nphibins=" << m_nphibins 
		<< std::endl;
	    throw OutOfBound(oss.str().c_str());
	  }
	  
	  m_data.intensity_it = m_I_begin + index*m_nEbins;
	  m_data.intensityE2_it = m_IE2_begin + index*m_nEbins;
	  m_data.solidangle = &(*(m_sa_begin+index));
	  m_data.solidangleE2 = &(*(m_saE2_begine+index));
	  m_data.nEbins = m_nEbins;
	  
	  return m_data;
	}

	
	iterator_t begin() 
	{
	  iterator_t it(*this);
	  return it;
	}
	
	iterator_t end() 
	{
	  iterator_t it(*this);
	  it.m_index = m_nphibins;
	  return it;
	}
	
      private:
	IntensityIterator m_I_begin, m_IE2_begin;
	SolidangleIterator m_sa_begin, m_saE2_begine;
	size_t m_nphibins, m_nEbins;
	mydatatype m_data;
      };
      
      
      
      
      template <typename Iterator, typename FLT>
      bool isEvenlySpaced(const Iterator &begin, const Iterator &end)
      {
	FLT epsilon = 1.e-7;
	
	assert (end-begin>1);
	FLT step=*(begin+1)-*begin;
	for (size_t i=1; i<end-begin-1; i++) {
	  FLT diff = std::abs( (*(begin+i+1)-*(begin+i))/step - 1. );
	  if ( diff> epsilon) return 0;
	}
	return 1;
      }
      
      template<typename pair_t, typename x_t, typename y_t>
      struct Get{
	void operator() (const pair_t &xy, x_t &x, y_t &y) const
	{
	  x = xy.first;
	  y = xy.second;
	}
      };   
	
    } // IpixE2IphiE_impl
    
    
    template<
      typename FLT, 
      typename InputBinIterator, typename InputDataIterator,
      typename OutputBinIterator, typename OutputDataIterator,
      typename MaskIterator
      >
    
    void IpixE2IphiE
    ( InputBinIterator ebb_begin, InputBinIterator ebb_end,
      InputDataIterator IEs_begin, InputDataIterator IEsE2_begin,
      
      OutputBinIterator outphibb_begin, OutputBinIterator outphibb_end,
      OutputDataIterator outS_begin, OutputDataIterator outSE2_begin,
      OutputDataIterator outsolidangle_begin, OutputDataIterator outsolidangleE2_begin,
      
      InputDataIterator phi_begin, 
      InputDataIterator solidangle_begin, InputDataIterator solidangleE2_begin,
      MaskIterator mask_begin,
      
      size_t size
      )
    {
      using namespace IpixE2IphiE_impl;
      
      assert (outphibb_end-outphibb_begin>1);
      assert (ebb_end-ebb_begin>1);
      
      if (!isEvenlySpaced<InputBinIterator, FLT>(ebb_begin, ebb_end) )
	  throw Exception("energy bin boundaries need to be evenly spaced.");
      if (!isEvenlySpaced<OutputBinIterator, FLT>(outphibb_begin, outphibb_end))
	  throw Exception("phi bin boundaries need to be evenly spaced.");

      size_t nphibins = outphibb_end-outphibb_begin-1;
      size_t nEbins = ebb_end-ebb_begin-1;

      typedef Y<OutputDataIterator, FLT> y_t;
      typedef YContainer<OutputDataIterator, OutputDataIterator, FLT> ycontainer_t;
      typedef typename ycontainer_t::iterator_t yiterator_t;
      ycontainer_t ycontainer
	(outS_begin, outSE2_begin, outsolidangle_begin, outsolidangleE2_begin, 
	 nphibins, nEbins);
      

      typedef Histogram::EvenlySpacedGridData_1D
	<FLT, y_t,  yiterator_t, unsigned int> griddata_t;
      FLT phistep = *(outphibb_begin+1) - *outphibb_begin;
      griddata_t griddata( *outphibb_begin, *(outphibb_end-1), phistep, ycontainer.begin());

      typedef FLT x_t;
      typedef std::pair<x_t, y_t> pair_t;
      typedef Get<pair_t, x_t, y_t> get_t;
      typedef Histogrammer1<pair_t, griddata_t, get_t, x_t, y_t> histogrammer_t;
      
      get_t get;
      histogrammer_t histogrammer(griddata, get);

      for (size_t i=0; i<size; i++) {

	if (*(mask_begin+i)) continue;
	
	x_t x = *(phi_begin+i);

	y_t y
	  (IEs_begin+i*nEbins, IEsE2_begin+i*nEbins,
	   *(solidangle_begin+i), *(solidangleE2_begin+i),
	   nEbins);
	
	pair_t xy(x,y);
	
	histogrammer(xy);
      }
    }
    
}}//namespace DANSE::Reduction


// version
// $Id$

// End of file 
